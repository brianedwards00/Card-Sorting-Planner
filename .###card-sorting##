(defun heuristic (momO)
(setq mom momO)
(setq h 0)
(setq value1 (reverse (pop mom)))
(setq value2 (pop mom))
(setq value3 (pop mom))
(setq i (length value2))
(dotimes (n i)
    (setq h (+ h n 1))
)
(setq i (length value3))
(dotimes (n i)
    (setq h (+ h n 1))
)
(setq i 0)
(setq value4 (sort (append value1 value3 value2 nil) #'string<))
(dolist (n value1)
    (if (equal n (car value4))
        (progn (pop value4) (setq i (+ i 1)))))
(setq i (- (length value1) i))
(dotimes (n i)
    (setq h (+ h n 2))
    )
    h
)

(defun generate-children (mom)
(setq mom-copy mom)
(setq state (cadr(member :state mom-copy)))
(setq value1 (nth 0 state))
(setq value2 (nth 1 state))
(setq value3 (nth 2 state))
(setq child-state '())
(setq child '())
(setq children '())
(if (string>  (car value1) (car value2))
    (progn
	(push value3 child-state)
	(push (append (list(car value1)) value2) child-state)
	(push (cdr value1) child-state)
	(push child-state child)
    	(push :state child)
    	(push (heuristic child-state) child)
    	(push :h child)
    	(push (cadr(member :id mom-copy)) child)
    	(push :mom child)
    	(push (gensym "n") child)
    	(push :id child)
	(push child children)
	)
     (push value3 child-state)
     (push (cdr value2) child-state)
     (push (append (list(car value2)) value1) child-state)
     (push child-state child)
     (push :state child)
     (push (heuristic child-state) child)
     (push :h child)
     (push (cadr(member :id mom-copy)) child)
     (push :mom child)
     (push (gensym "n") child)
     (push :id child)
     (push child children)
    )
(setq value1 (nth 0 state))
(setq value2 (nth 1 state))
(setq value3 (nth 2 state))
(setq child-state '())
(setq child '())
(if (string> (car value1) (car value3))
    (progn
	(push (append (list(car value1)) value3) child-state)
	(push value2 child-state)
	(push (cdr value1) child-state)
	(push child-state child)
    	(push :state child)
    	(push (heuristic child-state) child)
    	(push :h child)
    	(push (cadr(member :id mom-copy)) child)
    	(push :mom child)
    	(push (gensym "n") child)
    	(push :id child)
	(push child children)
	)
    (push (cdr value3) child-state)
    (push value2 child-state)
    (push (append (list(car value3)) value1) child-state)
    (push child-state child)
    (push :state child)
    (push (heuristic child-state) child)
    (push :h child)
    (push (cadr(member :id mom-copy)) child)
    (push :mom child)
    (push (gensym "n") child)
    (push :id child)
    (push child children)
    )
(setq value1 (nth 0 state))
(setq value2 (nth 1 state))
(setq value3 (nth 2 state))
(setq child-state '())
(setq child '())
(if (string> (car value2) (car value3))
    (progn
	(push (append (list(car value2)) value3) child-state)
	(push (cdr value2) child-state)
	(push value1 child-state)
	(push child-state child)
	(push :state child)
	(push (heuristic child-state) child)
	(push :h child)
	(push (cadr(member :id mom-copy)) child)
	(push :mom child)
	(push (gensym "n") child)
	(push :id child)
	(push child children)
	)
    (push (cdr value3) child-state)
    (push (append (list(car value3)) value2) child-state)
    (push value1 child-state)
    (push child-state child)
    (push :state child)
    (push (heuristic child-state) child)
    (push :h child)
    (push (cadr(member :id mom-copy)) child)
    (push :mom child)
    (push (gensym "n") child)
    (push :id child)
    (push child children)
    )
children
)


(defun card-sorting-planner (card-count start-state goal-state)
(setq open '())
(setq beginning '())
(push start-state beginning)
(push :state beginning)
(push (heuristic start-state) beginning)
(push :h beginning)
(push nil beginning)
(push :mom beginning)
(push (gensym "n") beginning)
(push :id beginning)
(push beginning open)
(car open)
(setq closed '())
;;TODO: Change to While Loop when done with project, or else it will crash
(dotimes(number 1) open
       (setq x (car open))
       (if(equal x goal-state) x
       		 (setq children (generate-children x))
		 children
		 ;;START CASE CODE HERE
		 )
       )
)

(card-sorting-planner 5 '((C A)(E B)(D)) '((E D C B A)()()))